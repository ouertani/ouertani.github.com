<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: SCALA | Ouertani Blog]]></title>
  <link href="http://ouertani.github.com/blog/categories/scala/atom.xml" rel="self"/>
  <link href="http://ouertani.github.com/"/>
  <updated>2013-04-01T03:39:13+02:00</updated>
  <id>http://ouertani.github.com/</id>
  <author>
    <name><![CDATA[Ouertani]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[XML/RPC driver as JCA Scala connector]]></title>
    <link href="http://ouertani.github.com/blog/2012/09/26/xml-slash-rpc-driver-as-jca-scala-connector/"/>
    <updated>2012-09-26T19:41:00+02:00</updated>
    <id>http://ouertani.github.com/blog/2012/09/26/xml-slash-rpc-driver-as-jca-scala-connector</id>
    <content type="html"><![CDATA[<p>Interoperability and reusability are key features of SOA architecture.</p>

<p>The <a href="http://en.wikipedia.org/wiki/Java_EE_Connector_Architecture">Java EE Connector architecture</a> defines a standard architecture for connecting the Java EE platform to heterogeneous EISs. This article presents an XML/RPC  adapter using a Scala JCA outbound connector to an IN/AIR legacy system.</p>

<h2>JCA and integration</h2>


<p><blockquote><p>"For enterprise application integration, bi-directional connectivity between enterprise applications and EIS is essential. The Java EE Connector architecture defines standard contracts that allow bi-directional connectivity between enterprise applications and EISs. It also formalizes the relationships, interactions, and the packaging of the integration layer, thus enabling enterprise application integration."</p></p><p><p></p><footer><strong>JCA 1.6 p 35</strong></footer></blockquote></p>

<p>The connector architecture defines a set of scalable, secure, and transactional mechanisms that enable the integration of EISs with application servers and enterprise application.</p>

<p><img class="center" src="/images/jca.jpg" width="350" height="350" title="JCA" alt="images"></p>

<p>Using a UCIP JCA connector rather than using an <a href="http://java.dzone.com/articles/xml-rpc-using-scala">XML/RPC raw driver</a> lets you:</p>

<ol>
<li>Hide connection complexity.</li>
<li>Use connection pooling and scalability.</li>
<li>Use a standard adapter that can be deployed with any JEE 6 server from an m x n integration problem to an m + n solution</li>
</ol>


<h2>How?</h2>


<p>The use of a <a href="http://www.jcp.org/en/jsr/detail?id=322">JCA</a> resource adapter inside a JEE solution is the same as interacting with a database or queue: protocol communication and wire negotiation... are hidden to the final user.</p>

<p>Two interfaces are presented to a customer:</p>

<h3>1) A factory trait:</h3>


<p><code>scala
trait AirConnectorFactory extends Referenceable with Function0[AirConnector]
</code></p>

<h3>2) The connector trait:</h3>


<p><code>scala
trait AirConnector {
def fire(elem : Elem) : Option[Elem]
}
</code>
As an outbound communication where the resource adapter allows an ESB or EE application server to connect to an IN/AIR node and perform work. All communication is initiated by the application. The Air connector factory should be injected as any resource and used like the following.
``` scala
@Resource(name="AIR")
var airConnectorFactory : AirConnectorFactory = _</p>

<p>val output = airConnectorFactory().fire(input)
```
<blockquote><p>Source code is based on JCA 1.6 specification and hosted on <a href="https://github.com/ouertani/TelcoCX">github</a>.</p></blockquote></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JAX-WS Header : Part 1 the Client Side]]></title>
    <link href="http://ouertani.github.com/blog/2012/06/27/jax-ws-header-part-1-the-client-side/"/>
    <updated>2012-06-27T03:32:00+02:00</updated>
    <id>http://ouertani.github.com/blog/2012/06/27/jax-ws-header-part-1-the-client-side</id>
    <content type="html"><![CDATA[<h2>Purpose</h2>


<p>Manipulating JAXWS header on the client Side like adding WSS username token or logging saop message.</p>

<h2>Introduction</h2>


<p>On Telecom IT environment and specially middelware solution, we will rarely do all the work but rather delegate some of business process to other tiers. Web service communications is heavy used between solutions. This tutorial aims to introduce using handler on client side by adding WSS UserToken or logging the soap message on console.</p>

<h2>Adding undeclared custom header</h2>


<p>Some Ws client needs to add a custom header which are not declared on WSDL. Adding WSS Username Token is like adding this XML snippet on header element:
```xml
&lt;soapenv:Header></p>

<pre><code>  &lt;wsse:Security  xmlns:wsse="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd" xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd"&gt;
     &lt;wsse:UsernameToken wsu:Id="UsernameToken-1"&gt;
        &lt;wsse:Username&gt;login&lt;/wsse:Username&gt;
        &lt;wsse:Password Type="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0#PasswordText"&gt;XXXX&lt;/wsse:Password&gt;        
     &lt;/wsse:UsernameToken&gt;
  &lt;/wsse:Security&gt;
</code></pre>

<p> &lt;/soapenv:Header>
<code>
Unlike &lt;a href="http://docs.oracle.com/javaee/5/api/javax/xml/ws/handler/LogicalHandler.html"&gt;LogicalHandler&lt;/a&gt; SOAPHandler have access to the entire Soap Message. Let's create an WSSUsernameTokenSecurityHandler Local Stateless Bean extending SOAPHandler to produce the previous header.
Below the WSSUsernameTokenSecurityHandler class
</code> java WSSUsernameTokenSecurityHandler.java
package me.slim.ouertani;</p>

<p>import java.util.Set;
import java.util.TreeSet;
import javax.annotation.Resource;
import javax.ejb.LocalBean;
import javax.ejb.Stateless;
import javax.xml.namespace.QName;
import javax.xml.soap.*;
import javax.xml.ws.handler.MessageContext;
import javax.xml.ws.handler.soap.SOAPHandler;
import javax.xml.ws.handler.soap.SOAPMessageContext;</p>

<p>@Stateless
@LocalBean
public class WSSUsernameTokenSecurityHandler implements SOAPHandler<SOAPMessageContext> {</p>

<pre><code>@Resource(lookup = "login")
private String login;
@Resource(lookup = "pwd")
private String pwd;

public WSSUsernameTokenSecurityHandler() {
}

@Override
public boolean handleMessage(SOAPMessageContext context) {

    Boolean outboundProperty =
            (Boolean) context.get(MessageContext.MESSAGE_OUTBOUND_PROPERTY);
    if (outboundProperty.booleanValue()) {

        try {
            SOAPEnvelope envelope = context.getMessage().getSOAPPart().getEnvelope();
            SOAPFactory factory = SOAPFactory.newInstance();
            String prefix = "wsse";
            String uri = "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd";
            SOAPElement securityElem =
                    factory.createElement("Security", prefix, uri);
            SOAPElement tokenElem =
                    factory.createElement("UsernameToken", prefix, uri);
            tokenElem.addAttribute(QName.valueOf("wsu:Id"), "UsernameToken-2");
            tokenElem.addAttribute(QName.valueOf("xmlns:wsu"), "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd");
            SOAPElement userElem =
                    factory.createElement("Username", prefix, uri);
            userElem.addTextNode(login);
            SOAPElement pwdElem =
                    factory.createElement("Password", prefix, uri);
            pwdElem.addTextNode(pwd);
            pwdElem.addAttribute(QName.valueOf("Type"), "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0#PasswordText");
            tokenElem.addChildElement(userElem);
            tokenElem.addChildElement(pwdElem);
            securityElem.addChildElement(tokenElem);
            SOAPHeader header = envelope.addHeader();
            header.addChildElement(securityElem);

        } catch (Exception e) {
            e.printStackTrace();
        }
    } else {
        // inbound
    }
    return true;
}

@Override
public Set&lt;QName&gt; getHeaders() {
    return new TreeSet();
}

@Override
public boolean handleFault(SOAPMessageContext context) {
    return false;
}

@Override
public void close(MessageContext context) {
    //
}
</code></pre>

<p>}
<code>
Next, declare the StatelessBean and inject both Webservice via @WebServiceRef and WSSUsernameTokenSecurityHandler via @EJB. A callback init method will add a HandlerResolver to the service. Below the full implementation
</code> java WebServiceClientBean.java
@Stateless
@LocalBean
public class WebServiceClientBean {</p>

<pre><code>@WebServiceRef()
private WsService service;
@EJB
private WSSUsernameTokenSecurityHandler wSSUsernameTokenSecurityHandler;

@PostConstruct
private void init() {
    service.setHandlerResolver( new HandlerResolver() {

        @Override
        public List&lt;Handler&gt; getHandlerChain(PortInfo portInfo) {
            List&lt;Handler&gt; handlerList = new ArrayList&lt;Handler&gt;();
            handlerList.add(wSSUsernameTokenSecurityHandler);
            return handlerList;
        }
    });
}
</code></pre>

<p>  public WsResponse getService(WsRequest wsRequest) {</p>

<pre><code>    WsPort port = service.getPort();
    return port.invoqueService(wsRequest);
}
</code></pre>

<p>}
```</p>

<h2>Logging SOAP messages</h2>


<p>Logging exchange xml message can be also using handlers, below the scala snippet handler used to log both in and out messages:
``` scala RequestResponsePrinter.scala
class RequestResponsePrinter  extends SOAPHandler[SOAPMessageContext] with LogHelper {</p>

<p>override def getHeaders(): Set[QName] = {</p>

<pre><code>return new TreeSet();
</code></pre>

<p>  }</p>

<p>  override def handleMessage(context: SOAPMessageContext): Boolean = {</p>

<pre><code>val sb = new ToStringBuilder(this).append("Call operation", "handleMessage");

L.debug(sb);
val outboundProperty = context.get(MessageContext.MESSAGE_OUTBOUND_PROPERTY).asInstanceOf[Boolean]


  try {
        val msg = context.getMessage()
        val out = new ByteArrayOutputStream();
        msg.writeTo(out);
        val strMsg = new String(out.toByteArray());
        L.debug("outbound  : "+outboundProperty.booleanValue()+" [" + strMsg + "]");

  } catch {
    case e: Exception =&gt;
      L.error(sb.append("EXCEPTION", e.getMessage()), e);
  }

return true;
</code></pre>

<p>  }</p>

<p>  override def handleFault(context: SOAPMessageContext): Boolean = {</p>

<pre><code>return false;
</code></pre>

<p>  }</p>

<p>  override def close(context: MessageContext) {</p>

<pre><code>//
</code></pre>

<p>  }
}
```</p>

<p>``` scala scala version of Handler resolver HandlerResolver.scala
new HandlerResolver() {</p>

<pre><code>  override def getHandlerChain(portInfo: PortInfo): java.util.List[javax.xml.ws.handler.Handler[_ &lt;: javax.xml.ws.handler.MessageContext]] = {
    import scala.collection.mutable.ArrayBuffer
    val handlerList = ArrayBuffer[Handler[_ &lt;: javax.xml.ws.handler.MessageContext]]()       
    handlerList += new RequestResponsePrinter()
    return handlerList

  }
};
</code></pre>

<p>```</p>

<h2>Conclusion</h2>


<p>We have heavily used handler on client side. On the server side things can change a bit, to be continued ...</p>
]]></content>
  </entry>
  
</feed>
