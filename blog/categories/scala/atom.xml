<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: SCALA | Ouertani Blog]]></title>
  <link href="http://ouertani.github.com/blog/categories/scala/atom.xml" rel="self"/>
  <link href="http://ouertani.github.com/"/>
  <updated>2013-04-01T03:49:32+02:00</updated>
  <id>http://ouertani.github.com/</id>
  <author>
    <name><![CDATA[Ouertani]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[JAX-WS Header : Part 1 the Client Side]]></title>
    <link href="http://ouertani.github.com/blog/2012/06/27/jax-ws-header-part-1-the-client-side/"/>
    <updated>2012-06-27T03:32:00+02:00</updated>
    <id>http://ouertani.github.com/blog/2012/06/27/jax-ws-header-part-1-the-client-side</id>
    <content type="html"><![CDATA[<h2>Purpose</h2>


<p>Manipulating JAXWS header on the client Side like adding WSS username token or logging saop message.</p>

<h2>Introduction</h2>


<p>On Telecom IT environment and specially middelware solution, we will rarely do all the work but rather delegate some of business process to other tiers. Web service communications is heavy used between solutions. This tutorial aims to introduce using handler on client side by adding WSS UserToken or logging the soap message on console.</p>

<h2>Adding undeclared custom header</h2>


<p>Some Ws client needs to add a custom header which are not declared on WSDL. Adding WSS Username Token is like adding this XML snippet on header element:
```xml
&lt;soapenv:Header></p>

<pre><code>  &lt;wsse:Security  xmlns:wsse="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd" xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd"&gt;
     &lt;wsse:UsernameToken wsu:Id="UsernameToken-1"&gt;
        &lt;wsse:Username&gt;login&lt;/wsse:Username&gt;
        &lt;wsse:Password Type="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0#PasswordText"&gt;XXXX&lt;/wsse:Password&gt;        
     &lt;/wsse:UsernameToken&gt;
  &lt;/wsse:Security&gt;
</code></pre>

<p> &lt;/soapenv:Header>
<code>
Unlike &lt;a href="http://docs.oracle.com/javaee/5/api/javax/xml/ws/handler/LogicalHandler.html"&gt;LogicalHandler&lt;/a&gt; SOAPHandler have access to the entire Soap Message. Let's create an WSSUsernameTokenSecurityHandler Local Stateless Bean extending SOAPHandler to produce the previous header.
Below the WSSUsernameTokenSecurityHandler class
</code> java WSSUsernameTokenSecurityHandler.java
package me.slim.ouertani;</p>

<p>import java.util.Set;
import java.util.TreeSet;
import javax.annotation.Resource;
import javax.ejb.LocalBean;
import javax.ejb.Stateless;
import javax.xml.namespace.QName;
import javax.xml.soap.*;
import javax.xml.ws.handler.MessageContext;
import javax.xml.ws.handler.soap.SOAPHandler;
import javax.xml.ws.handler.soap.SOAPMessageContext;</p>

<p>@Stateless
@LocalBean
public class WSSUsernameTokenSecurityHandler implements SOAPHandler<SOAPMessageContext> {</p>

<pre><code>@Resource(lookup = "login")
private String login;
@Resource(lookup = "pwd")
private String pwd;

public WSSUsernameTokenSecurityHandler() {
}

@Override
public boolean handleMessage(SOAPMessageContext context) {

    Boolean outboundProperty =
            (Boolean) context.get(MessageContext.MESSAGE_OUTBOUND_PROPERTY);
    if (outboundProperty.booleanValue()) {

        try {
            SOAPEnvelope envelope = context.getMessage().getSOAPPart().getEnvelope();
            SOAPFactory factory = SOAPFactory.newInstance();
            String prefix = "wsse";
            String uri = "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd";
            SOAPElement securityElem =
                    factory.createElement("Security", prefix, uri);
            SOAPElement tokenElem =
                    factory.createElement("UsernameToken", prefix, uri);
            tokenElem.addAttribute(QName.valueOf("wsu:Id"), "UsernameToken-2");
            tokenElem.addAttribute(QName.valueOf("xmlns:wsu"), "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd");
            SOAPElement userElem =
                    factory.createElement("Username", prefix, uri);
            userElem.addTextNode(login);
            SOAPElement pwdElem =
                    factory.createElement("Password", prefix, uri);
            pwdElem.addTextNode(pwd);
            pwdElem.addAttribute(QName.valueOf("Type"), "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0#PasswordText");
            tokenElem.addChildElement(userElem);
            tokenElem.addChildElement(pwdElem);
            securityElem.addChildElement(tokenElem);
            SOAPHeader header = envelope.addHeader();
            header.addChildElement(securityElem);

        } catch (Exception e) {
            e.printStackTrace();
        }
    } else {
        // inbound
    }
    return true;
}

@Override
public Set&lt;QName&gt; getHeaders() {
    return new TreeSet();
}

@Override
public boolean handleFault(SOAPMessageContext context) {
    return false;
}

@Override
public void close(MessageContext context) {
    //
}
</code></pre>

<p>}
<code>
Next, declare the StatelessBean and inject both Webservice via @WebServiceRef and WSSUsernameTokenSecurityHandler via @EJB. A callback init method will add a HandlerResolver to the service. Below the full implementation
</code> java WebServiceClientBean.java
@Stateless
@LocalBean
public class WebServiceClientBean {</p>

<pre><code>@WebServiceRef()
private WsService service;
@EJB
private WSSUsernameTokenSecurityHandler wSSUsernameTokenSecurityHandler;

@PostConstruct
private void init() {
    service.setHandlerResolver( new HandlerResolver() {

        @Override
        public List&lt;Handler&gt; getHandlerChain(PortInfo portInfo) {
            List&lt;Handler&gt; handlerList = new ArrayList&lt;Handler&gt;();
            handlerList.add(wSSUsernameTokenSecurityHandler);
            return handlerList;
        }
    });
}
</code></pre>

<p>  public WsResponse getService(WsRequest wsRequest) {</p>

<pre><code>    WsPort port = service.getPort();
    return port.invoqueService(wsRequest);
}
</code></pre>

<p>}
```</p>

<h2>Logging SOAP messages</h2>


<p>Logging exchange xml message can be also using handlers, below the scala snippet handler used to log both in and out messages:
``` scala RequestResponsePrinter.scala
class RequestResponsePrinter  extends SOAPHandler[SOAPMessageContext] with LogHelper {</p>

<p>override def getHeaders(): Set[QName] = {</p>

<pre><code>return new TreeSet();
</code></pre>

<p>  }</p>

<p>  override def handleMessage(context: SOAPMessageContext): Boolean = {</p>

<pre><code>val sb = new ToStringBuilder(this).append("Call operation", "handleMessage");

L.debug(sb);
val outboundProperty = context.get(MessageContext.MESSAGE_OUTBOUND_PROPERTY).asInstanceOf[Boolean]


  try {
        val msg = context.getMessage()
        val out = new ByteArrayOutputStream();
        msg.writeTo(out);
        val strMsg = new String(out.toByteArray());
        L.debug("outbound  : "+outboundProperty.booleanValue()+" [" + strMsg + "]");

  } catch {
    case e: Exception =&gt;
      L.error(sb.append("EXCEPTION", e.getMessage()), e);
  }

return true;
</code></pre>

<p>  }</p>

<p>  override def handleFault(context: SOAPMessageContext): Boolean = {</p>

<pre><code>return false;
</code></pre>

<p>  }</p>

<p>  override def close(context: MessageContext) {</p>

<pre><code>//
</code></pre>

<p>  }
}
```</p>

<p>``` scala scala version of Handler resolver HandlerResolver.scala
new HandlerResolver() {</p>

<pre><code>  override def getHandlerChain(portInfo: PortInfo): java.util.List[javax.xml.ws.handler.Handler[_ &lt;: javax.xml.ws.handler.MessageContext]] = {
    import scala.collection.mutable.ArrayBuffer
    val handlerList = ArrayBuffer[Handler[_ &lt;: javax.xml.ws.handler.MessageContext]]()       
    handlerList += new RequestResponsePrinter()
    return handlerList

  }
};
</code></pre>

<p>```</p>

<h2>Conclusion</h2>


<p>We have heavily used handler on client side. On the server side things can change a bit, to be continued ...</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Basic MDB with Scala]]></title>
    <link href="http://ouertani.github.com/blog/2011/09/11/basic-mdb-with-scala/"/>
    <updated>2011-09-11T03:41:00+02:00</updated>
    <id>http://ouertani.github.com/blog/2011/09/11/basic-mdb-with-scala</id>
    <content type="html"><![CDATA[<p>While I am Akka fun, Typesafe follower, in this post I will continue presenting scala on JEE 6 environment and introduce basic message driven bean (MDB ) using scala language.</p>

<p>As an example let's take a simple one MDB that will consome operation command like add and substract and my be asked to replay by the result</p>

<h2>I- Exchange API</h2>


<p><code>scala
sealed trait TOperation
case class Add(x:Int) extends  TOperation
case class Sub(x:Int) extends TOperation
case class Sum extends TOperation
case class Count(x:Int) extends TOperation
</code></p>

<h2>II- The listener</h2>


<p>The object
<code>scala
object MDbListener {
  var count = 0
  val L = Logger.getLogger(classOf[MDbListener])
}
</code>
The class
``` scala
@MessageDriven(
  messageListenerInterface=classOf[MessageListener],
  mappedName = "jms/toMdb",
  activationConfig = Array(</p>

<pre><code>new ActivationConfigProperty(propertyName = "acknowledgeMode", propertyValue = "Auto-acknowledge"),
new ActivationConfigProperty(propertyName = "destinationType", propertyValue = "javax.jms.Queue")))
</code></pre>

<p>class MDbListener extends MessageListener {</p>

<p>  import MDbListener._</p>

<p>  override def onMessage(message: Message) {</p>

<pre><code>L.debug("Message Received")

message match {
  case o: ObjectMessage =&gt; {
      try {
        val obj = o.getObject()
        obj match {
          case action: TOperation =&gt; handle(action)
          case _ =&gt; L.warn("Unkownen msg")
        }
      } catch {
        case ex: Exception =&gt; L.error("&gt;&gt;&gt; Exception", ex)
      }

    }
  case _ =&gt; L.warn("unknown msg")
}
</code></pre>

<p>  }</p>

<p>  def handle(op: TOperation ) = op match {/<em> TODO </em>/
  }
}
```
Nothing especial here but be careful to not forget adding messageListenerInterface=classOf[MessageListener] on MessageDriven annotation this is because ScalaObject super class and that's all for the listener.</p>

<h2>III- The sender</h2>


<p>The handle method will do mathematical operation and can be requested to send the sum to another JMS Queue.
``` scala
def handle(op: TOperation ) = op match {</p>

<pre><code>case   Add(x) =&gt; count +=x
case   Sub(x) =&gt; count -=x
case   s:Sum =&gt;  sendJMSMessageToTt( Count (count))
case   c:Count =&gt; L.warn ("Wrong message destination!")
</code></pre>

<p>  }
```
Very easy with pattern matching!</p>

<p>The sendJmsMessageToIt method can be done like the following</p>

<p>``` scala
@Resource(mappedName = "jms/Rep")
 var  queue :Queue=<em>
 @Resource(mappedName = "jms/RepFactory")
 var  factory:ConnectionFactory=</em></p>

<p> private [ws ] def sendJMSMessageToTt( messageData:Count)  {
   def  createJMSMessageForjmsTt( session:Session,  messageData:Count):Message={</p>

<pre><code> val om = session.createObjectMessage()
 om.setObject(messageData)
 om
</code></pre>

<p>   }</p>

<p>   def tryWith<a href="ac%20:A">A&lt;%{ def close()}</a>(f: A=> Unit)
   {</p>

<pre><code> try {f} finally { ac.close }
</code></pre>

<p>   }</p>

<p>   tryWith(factory.createConnection()){</p>

<pre><code> connection =&gt; tryWith(connection.createSession(false, Session.AUTO_ACKNOWLEDGE)) {
    session =&gt;  tryWith( session createProducer queue ){
            messageProducer =&gt; messageProducer.send(createJMSMessageForjmsTt(session, messageData))
   }
 }
</code></pre>

<p>   }
 }
```
Here we used an old trick to manage resources : <a href="http://www.jroller.com/ouertani/entry/scala_try_with_resources">http://www.jroller.com/ouertani/entry/scala_try_with_resources</a></p>
]]></content>
  </entry>
  
</feed>
